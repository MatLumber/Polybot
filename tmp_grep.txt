/root/Polybot/src/main.rs.backup:94:                let now = chrono::Utc::now().timestamp_millis();                let key = (tick.asset, timeframe);                let last = last_feature_time.entry(key).or_insert(0);                if now - *last > 10000 {                    *last = now;                    tracing::info!(                        asset = ?tick.asset,                        timeframe = ?timeframe,                        candle_count = candle_count,                        "üïØÔ∏è Candle count"                    );                }                // Need at least 30 candles for meaningful technical indicators
/root/Polybot/src/main.rs:104:                let now = chrono::Utc::now().timestamp_millis();                let key = (tick.asset, timeframe);                let last = last_feature_time.entry(key).or_insert(0);                if now - *last > 10000 {                    *last = now;                    tracing::info!(                        asset = ?tick.asset,                        timeframe = ?timeframe,                        candle_count = candle_count,                        "üïØÔ∏è Candle count"                    );                }                // Need at least 30 candles for meaningful technical indicators
/root/Polybot/src/main.rs.minified.bak:1://! PolyBot - Directional Trading Bot for Polymarket//!//! Predicts UP/DOWN direction for 15m/1h BTC/ETH/SOL/XRP markets//! using Polymarket-native RTDS + CLOB market data.mod backtesting;mod clob;mod config;mod features;mod oracle;mod paper_trading;mod persistence;mod polymarket;mod risk;mod strategy;mod types;#[cfg(feature = "dashboard")]mod dashboard;use anyhow::Result;use std::sync::Arc;use tokio::sync::{mpsc, Mutex};use tracing::{error, info, warn};use tracing_subscriber::{fmt, layer::SubscriberExt, util::SubscriberInitExt, EnvFilter};use crate::clob::{ClobClient, Order};use crate::config::AppConfig;use crate::features::{FeatureEngine, Features, MarketRegime, OrderbookImbalanceTracker};use crate::oracle::PriceAggregator;use crate::paper_trading::{PaperTradingConfig, PaperTradingEngine};use crate::persistence::{BalanceTracker, CsvPersistence, HardResetOptions};use crate::risk::RiskManager;use crate::strategy::{StrategyConfig, StrategyEngine, TradeResult};use crate::types::{Asset, Direction, FeatureSet, PriceSource, PriceTick, Signal, Timeframe};#[cfg(feature = "dashboard")]use crate::dashboard::{PaperStatsResponse, PositionResponse, TradeResponse};const BOT_TAG: &str = env!("CARGO_PKG_VERSION");#[tokio::main]async fn main() -> Result<()> {    // Initialize logging    init_logging()?;    info!(        bot_tag = %BOT_TAG,        "ü§ñ PolyBot v{} starting...", BOT_TAG    );    #[cfg(feature = "dashboard")]    info!("üñ•Ô∏è Dashboard feature ENABLED - server will start on port 3000");    #[cfg(not(feature = "dashboard"))]    info!("üñ•Ô∏è Dashboard feature DISABLED");    // Load configuration    let runtime_args = parse_runtime_args()?;    let config = AppConfig::load()?;    info!(config_digest = %config.digest(), "‚úÖ Configuration loaded");    let _startup_reset_executed = maybe_run_startup_reset(&config, &runtime_args)?;    if runtime_args.reset_mode.is_some() {        info!("Reset command completed; exiting by CLI request");        return Ok(());    }    // Validate environment    config.validate_env()?;    // Create channels for inter-component communication    let (price_tx, mut price_rx) = mpsc::channel::<PriceTick>(1000);    let (paper_price_tx, mut paper_price_rx) = mpsc::channel::<PriceTick>(1000);    let (feature_tx, mut feature_rx) = mpsc::channel::<Features>(500);    let (signal_tx, mut signal_rx) = mpsc::channel::<Signal>(100);    let (order_tx, mut order_rx) = mpsc::channel::<Order>(100);    // Initialize components    let oracle = Arc::new(PriceAggregator::new(5000, 2, 100));    let feature_engine = Arc::new(Mutex::new(FeatureEngine::new()));    // ‚îÄ‚îÄ Orderbook Imbalance Tracker (for microstructure analysis) ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ    let orderbook_tracker = Arc::new(std::sync::Mutex::new(OrderbookImbalanceTracker::new()));    {        let tracker_clone = orderbook_tracker.clone();        feature_engine            .lock()            .await            .set_orderbook_tracker(tracker_clone);    }    info!("üìä OrderbookImbalanceTracker connected to FeatureEngine");    let strategy = Arc::new(Mutex::new(StrategyEngine::new(StrategyConfig::default())));    // Load calibrator state (v2 preferred, v1 fallback)    let calibrator_state_file_v1 =        std::path::PathBuf::from(&config.persistence.data_dir).join("calibrator_state.json");    let calibrator_state_file_v2 =        std::path::PathBuf::from(&config.persistence.data_dir).join("calibrator_state_v2.json");    let mut loaded_calibrator_state = false;    if calibrator_state_file_v2.exists() {        match std::fs::read_to_string(&calibrator_state_file_v2) {            Ok(json) => match serde_json::from_str::<                std::collections::HashMap<String, Vec<strategy::IndicatorStats>>,            >(&json)            {                Ok(stats_by_market) => {                    strategy                        .lock()                        .await                        .import_calibrator_state_v2(stats_by_market);                    loaded_calibrator_state = true;                    info!(                        path = %calibrator_state_file_v2.display(),                        "Loaded calibrator v2 state from disk"                    );                }                Err(e) => warn!(error = %e, "Failed to parse calibrator v2 state"),            },            Err(e) => warn!(error = %e, "Failed to read calibrator v2 state file"),        }    } else if calibrator_state_file_v1.exists() {        match std::fs::read_to_string(&calibrator_state_file_v1) {            Ok(json) => match serde_json::from_str::<Vec<strategy::IndicatorStats>>(&json) {                Ok(stats) => {                    let total: usize = stats.iter().map(|s| s.total_signals).max().unwrap_or(0);                    strategy.lock().await.import_calibrator_state(stats);                    loaded_calibrator_state = true;                    info!(                        trades = total,                        path = %calibrator_state_file_v1.display(),                        "Loaded legacy calibrator v1 state from disk"                    );                }                Err(e) => warn!(error = %e, "Failed to parse calibrator v1 state"),            },            Err(e) => warn!(error = %e, "Failed to read calibrator v1 state file"),        }    } else {        info!("No calibrator state file found, starting with fresh market learning");    }    let risk_manager = Arc::new(RiskManager::new(risk::RiskConfig::default()));    let dry_run = config.bot.dry_run;    let clob_client = Arc::new(ClobClient::with_dry_run(config.execution.clone(), dry_run));    let paper_trading_enabled = config.paper_trading.enabled;    if paper_trading_enabled {        info!(            "üìã PAPER TRADING mode enabled - virtual balance: ${:.2}",            config.paper_trading.initial_balance        );    } else if dry_run {        info!("üß™ DRY_RUN mode enabled - no real orders will be submitted");    } else {        warn!("‚ö†Ô∏è LIVE mode enabled - real orders will be submitted!");    }    let csv_persistence = Arc::new(CsvPersistence::new(&config.persistence.data_dir)?);    let balance_tracker = Arc::new(BalanceTracker::new());    if !loaded_calibrator_state {        info!("Fresh calibrator start: bootstrap from Binance is disabled");    }    // ‚îÄ‚îÄ Dashboard API (optional, only with feature flag) ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ    #[cfg(feature = "dashboard")]    let (dashboard_memory, dashboard_broadcaster) = {        let memory = std::sync::Arc::new(dashboard::DashboardMemory::new(            config.paper_trading.initial_balance,        ));        let broadcaster = dashboard::WebSocketBroadcaster::new(100);        (memory, broadcaster)    };    #[cfg(feature = "dashboard")]    {        let strat = strategy.lock().await;        let snapshot = strat.export_calibrator_state_v2();        let quality = strat.export_calibration_quality_by_market();        drop(strat);        dashboard_memory.set_market_learning_stats(snapshot).await;        dashboard_memory            .set_calibration_quality_stats(quality)            .await;    }    #[cfg(feature = "dashboard")]    let dashboard_handle = {        let memory = dashboard_memory.clone();        let broadcaster = dashboard_broadcaster.clone();        let csv_persistence_clone = csv_persistence.clone();        let reset_executed = _startup_reset_executed;        tokio::spawn(async move {            info!("Dashboard spawn started - initializing server...");            if reset_executed {                info!("[1/6] Startup reset executed; skipping dashboard historical bootstrap");            } else {                // Load historical paper trades on startup                info!("[1/6] Loading historical paper trades...");                match csv_persistence_clone.load_recent_paper_trades(10_000) {                    Ok(trades) => {                        info!("[2/6] Loaded {} trades from CSV", trades.len());                        if !trades.is_empty() {                            info!("Loaded {} historical paper trades", trades.len());                            memory.set_paper_trades(trades).await;                            info!("[2b/6] set_paper_trades completed");                        }                    }                    Err(e) => {                        warn!(error = %e, "Failed to load historical paper trades");                    }                }                info!("[3/6] Loading recent BTC/ETH price history...");                match csv_persistence_clone                    .load_recent_price_history(&[Asset::BTC, Asset::ETH], 86_400)                {                    Ok(rows) => {                        info!("[4/6] Loaded {} rows for chart bootstrap", rows.len());                        for (asset, timestamp, price, source) in rows {                            memory                                .seed_price_history_point(asset, price, source, timestamp)                                .await;                        }                    }                    Err(e) => {                        warn!(error = %e, "Failed to load recent price history for dashboard bootstrap");                    }                }            }            // Heartbeat helps the frontend detect stale connections.            let heartbeat_broadcaster = broadcaster.clone();            tokio::spawn(async move {                let mut interval = tokio::time::interval(tokio::time::Duration::from_secs(10));                loop {                    interval.tick().await;                    heartbeat_broadcaster.broadcast_heartbeat();                }            });            info!("[5/6] Starting dashboard server on port 3000...");            match dashboard::start_server(memory, broadcaster, 3000).await {                Ok(()) => {                    info!("[6/6] start_server returned successfully (unexpected)");                }                Err(e) => {                    error!(error = %e, "Dashboard server failed to start");                }            }        })    };    // Paper trading engine (only used when paper_trading.enabled = true)    // Create share price provider that will be populated by orderbook feed    let polymarket_share_prices = std::sync::Arc::new(paper_trading::PolymarketSharePrices::new());    let share_prices_for_orderbook = polymarket_share_prices.clone();    let paper_engine = if paper_trading_enabled {        let pt_config = PaperTradingConfig {            initial_balance: config.paper_trading.initial_balance,            slippage_bps: config.paper_trading.slippage_bps,            fee_bps: config.paper_trading.fee_bps,            trailing_stop_pct: config.paper_trading.trailing_stop_pct,            take_profit_pct: config.paper_trading.take_profit_pct,            max_hold_duration_ms: config.paper_trading.max_hold_duration_ms,            dashboard_interval_secs: config.paper_trading.dashboard_interval_secs,            prefer_chainlink: config.paper_trading.prefer_chainlink,            native_only: config                .polymarket                .data_mode                .eq_ignore_ascii_case("native_only"),            checkpoint_arm_roi: config.risk.checkpoint_arm_roi,            checkpoint_initial_floor_roi: config.risk.checkpoint_initial_floor_roi,            checkpoint_trail_gap_roi: config.risk.checkpoint_trail_gap_roi,            hard_stop_roi: config.risk.hard_stop_roi,            time_stop_seconds_to_expiry: config.risk.time_stop_seconds_to_expiry,            kelly_enabled: config.kelly.enabled,            kelly_fraction_15m: config.kelly.fraction_15m,            kelly_fraction_1h: config.kelly.fraction_1h,            kelly_cap_15m: config.kelly.max_bankroll_fraction_15m,            kelly_cap_1h: config.kelly.max_bankroll_fraction_1h,        };        // State file path for persistence        let state_file =            std::path::PathBuf::from(&config.persistence.data_dir).join("paper_trading_state.json");        let engine = PaperTradingEngine::new(pt_config)            .with_persistence(csv_persistence.clone())            .with_state_file(state_file)            .with_polymarket_share_prices(polymarket_share_prices.clone());        // Load previous state if exists        let engine = Arc::new(engine);        if let Err(e) = engine.load_state() {            warn!(error = %e, "Failed to load paper trading state, starting fresh");        }        info!("üìã [PAPER] Connected to real Polymarket share prices via orderbook feed");        // ‚îÄ‚îÄ Connect calibration callback via channel ‚îÄ‚îÄ        // This allows the paper engine to update indicator weights when trades close        // We use a channel because the callback is sync but strategy uses async Mutex        let (calibration_tx, mut calibration_rx) =            mpsc::channel::<(Asset, Timeframe, Vec<String>, bool, f64)>(100);        let strategy_for_calibration = strategy.clone();        let calibrator_save_path = calibrator_state_file_v2.clone();        // Spawn task to process calibration events and persist to disk        tokio::spawn(async move {            while let Some((asset, timeframe, indicators, is_win, p_model)) =                calibration_rx.recv().await            {                let result = if is_win {                    TradeResult::Win                } else {                    TradeResult::Loss                };                let mut s = strategy_for_calibration.lock().await;                s.record_trade_with_indicators_for_market(asset, timeframe, &indicators, result);                s.record_prediction_outcome_for_market(asset, timeframe, p_model, is_win);                // Save calibrator state to disk after each trade                let stats = s.export_calibrator_state_v2();                let total_trades = s.calibrator_total_trades();                let is_calibrated = s.is_calibrated();                drop(s);                // Persist to JSON file                match serde_json::to_string_pretty(&stats) {                    Ok(json) => {                        if let Err(e) = std::fs::write(&calibrator_save_path, &json) {                            warn!(error = %e, "Failed to save calibrator state");                        }                    }                    Err(e) => warn!(error = %e, "Failed to serialize calibrator state"),                }                info!(                    asset = ?asset,                    timeframe = ?timeframe,                    is_win = is_win,                    p_model = p_model,                    indicators_count = indicators.len(),                    total_trades = total_trades,                    calibrated = is_calibrated,                    "üß† [CALIBRATION] Recorded trade result & saved to disk"                );            }        });        let calibration_callback: std::sync::Arc<paper_trading::CalibrationCallback> =            std::sync::Arc::new(Box::new(                move |_asset: Asset,                      timeframe: Timeframe,                      indicators: &[String],                      is_win: bool,                      p_model: f64| {                    let _ = calibration_tx.try_send((                        _asset,                        timeframe,                        indicators.to_vec(),                        is_win,                        p_model,                    ));                },            ) as paper_trading::CalibrationCallback);        // Recreate engine with callback        let pt_config = PaperTradingConfig {            initial_balance: config.paper_trading.initial_balance,            slippage_bps: config.paper_trading.slippage_bps,            fee_bps: config.paper_trading.fee_bps,            trailing_stop_pct: config.paper_trading.trailing_stop_pct,            take_profit_pct: config.paper_trading.take_profit_pct,            max_hold_duration_ms: config.paper_trading.max_hold_duration_ms,            dashboard_interval_secs: config.paper_trading.dashboard_interval_secs,            prefer_chainlink: config.paper_trading.prefer_chainlink,            native_only: config                .polymarket                .data_mode                .eq_ignore_ascii_case("native_only"),            checkpoint_arm_roi: config.risk.checkpoint_arm_roi,            checkpoint_initial_floor_roi: config.risk.checkpoint_initial_floor_roi,            checkpoint_trail_gap_roi: config.risk.checkpoint_trail_gap_roi,            hard_stop_roi: config.risk.hard_stop_roi,            time_stop_seconds_to_expiry: config.risk.time_stop_seconds_to_expiry,            kelly_enabled: config.kelly.enabled,            kelly_fraction_15m: config.kelly.fraction_15m,            kelly_fraction_1h: config.kelly.fraction_1h,            kelly_cap_15m: config.kelly.max_bankroll_fraction_15m,            kelly_cap_1h: config.kelly.max_bankroll_fraction_1h,        };        let state_file =            std::path::PathBuf::from(&config.persistence.data_dir).join("paper_trading_state.json");        let mut new_engine = PaperTradingEngine::new(pt_config)            .with_persistence(csv_persistence.clone())            .with_state_file(state_file)            .with_polymarket_share_prices(polymarket_share_prices.clone())            .with_calibration_callback(calibration_callback);        // Copy state from old engine        if let Err(e) = new_engine.load_state() {            warn!(error = %e, "Failed to load paper trading state in new engine");        }        Some(Arc::new(new_engine))    } else {        None    };    info!("‚úÖ All components initialized");    // ‚îÄ‚îÄ Polymarket Orderbook Feed (WebSocket) ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ    // Connects to Polymarket's WebSocket to receive real-time orderbook data    // for BTC/ETH markets. This populates the OrderbookImbalanceTracker    // AND provides real share prices for paper trading.    let orderbook_feed_tracker = orderbook_tracker.clone();    let orderbook_feed_client = clob_client.clone();    let orderbook_share_prices = share_prices_for_orderbook.clone();    let orderbook_feed_handle = tokio::spawn(async move {        use crate::clob::{MarketFeedClient, WsEvent, WsMessage};        use std::collections::HashMap as StdHashMap;        // Wait a bit for markets to be loaded        tokio::time::sleep(tokio::time::Duration::from_secs(5)).await;        // Fetch token IDs for BTC/ETH markets and build token_id ‚Üí (Asset, Timeframe) mapping        let mut token_ids: Vec<String> = Vec::new();        let mut token_map: StdHashMap<String, (Asset, Timeframe, Direction)> = StdHashMap::new();        // Resolve the best available tradeable markets for each strategy lane.        let market_targets: Vec<(Asset, Timeframe)> = vec![            (Asset::BTC, Timeframe::Min15),            (Asset::BTC, Timeframe::Hour1),            (Asset::ETH, Timeframe::Min15),            (Asset::ETH, Timeframe::Hour1),        ];        for (asset, tf) in &market_targets {            match orderbook_feed_client                .find_tradeable_market_for_signal(*asset, *tf)                .await            {                Some(market) => {                    let resolved_slug = market.slug.clone().unwrap_or_else(|| market.question.clone());                    // Each market has two tokens: YES and NO                    // We need to identify which is UP (YES) and which is DOWN (NO)                    for (idx, token) in market.tokens.iter().enumerate() {                        token_ids.push(token.token_id.clone());                        // First token is typically YES (UP), second is NO (DOWN)                        let outcome = token.outcome.to_ascii_lowercase();                        let direction = if outcome.contains("yes") || outcome.contains("up") {                            Direction::Up                        } else if outcome.contains("no") || outcome.contains("down") {                            Direction::Down                        } else if idx == 0 {                            Direction::Up                        } else {                            Direction::Down                        };                        token_map.insert(token.token_id.clone(), (*asset, *tf, direction));                        info!(                            market_slug = %resolved_slug,                            token_id = %token.token_id,                            asset = ?asset,                            timeframe = ?tf,                            direction = ?direction,                            outcome = %token.outcome,                            "Mapped market for orderbook feed"                        );                    }                }                None => {                    warn!(asset = ?asset, timeframe = ?tf, "No tradeable market found for orderbook feed");                }            }        }        if token_ids.is_empty() {            warn!("üìä No markets found for orderbook feed, skipping WebSocket connection");            return;        }        info!(            count = token_ids.len(),            mapped = token_map.len(),            "üìä Starting Polymarket orderbook WebSocket"        );        let (event_tx, mut event_rx) = mpsc::channel::<WsEvent>(100);        let url = "wss://ws-subscriptions-clob.polymarket.com/ws/market";        let client = MarketFeedClient::new(url, event_tx);        let (subscribe_tx, subscribe_rx) = mpsc::channel::<Vec<String>>(10);        let (shutdown_tx, shutdown_rx) = mpsc::channel::<()>(1);        // Run the client in a separate task        let client_handle = tokio::spawn(async move {            if let Err(e) = client.run(token_ids, subscribe_rx, shutdown_rx).await {                error!(error = %e, "Orderbook feed client error");            }        });        // Process events and update tracker ‚Äî using token_id mapping for correct routing        while let Some(event) = event_rx.recv().await {            match event {                WsEvent::BookUpdate(book) => {                    // Calculate midpoint from orderbook as the real share price                    let midpoint = book.mid_price().unwrap_or(0.0);                    let spread = book.spread().unwrap_or(0.0);                    let spread_bps = if midpoint > 0.0 {                        spread / midpoint * 10000.0                    } else {                        0.0                    };                    // Update orderbook tracker                    if let Ok(mut tracker) = orderbook_feed_tracker.lock() {                        // Route to correct (Asset, Timeframe) using token_id mapping                        if let Some(&(asset, tf, direction)) = token_map.get(&book.token_id) {                            tracker.update_orderbook(&book, asset, tf);                            // Update real share price for paper trading                            if midpoint > 0.0 {                                let bid = book.best_bid().map(|b| b.price).unwrap_or(midpoint);                                let ask = book.best_ask().map(|a| a.price).unwrap_or(midpoint);                                let bid_size = book.best_bid().map(|b| b.size).unwrap_or(0.0);                                let ask_size = book.best_ask().map(|a| a.size).unwrap_or(0.0);                                let depth_top5 =                                    book.bids.iter().take(5).map(|b| b.size).sum::<f64>()                                        + book.asks.iter().take(5).map(|a| a.size).sum::<f64>();                                let direction_str = match direction {                                    Direction::Up => "UP",                                    Direction::Down => "DOWN",                                };                                orderbook_share_prices.update_quote_with_depth(                                    asset,                                    tf,                                    direction_str,                                    bid,                                    ask,                                    midpoint,                                    bid_size,                                    ask_size,                                    depth_top5,                                );                                info!(                                    token_id = %book.token_id,                                    asset = ?asset,                                    timeframe = ?tf,                                    direction = ?direction,                                    bid = bid,                                    ask = ask,                                    mid = midpoint,                                    spread_bps = spread_bps,                                    "üìä Real share prices updated from orderbook"                                );                            }                        } else {                            // Unknown token_id ‚Äî skip (don't pollute other assets)                            warn!(token_id = %book.token_id, "üìä Unknown token_id in book update, skipping");                        }                    }                }                WsEvent::MarketUpdate(data) => {                    let mapped = token_map.get(&data.token_id).copied();                    if let Some(book) = &data.orderbook {                        let midpoint = book.mid_price().unwrap_or(0.0);                        if let Ok(mut tracker) = orderbook_feed_tracker.lock() {                            if let Some((asset, tf, direction)) = mapped {                                tracker.update_orderbook(book, asset, tf);                                // Update real share prices                                if midpoint > 0.0 {                                    let bid = book.best_bid().map(|b| b.price).unwrap_or(midpoint);                                    let ask = book.best_ask().map(|a| a.price).unwrap_or(midpoint);                                    let bid_size = book.best_bid().map(|b| b.size).unwrap_or(0.0);                                    let ask_size = book.best_ask().map(|a| a.size).unwrap_or(0.0);                                    let depth_top5 =                                        book.bids.iter().take(5).map(|b| b.size).sum::<f64>()                                            + book.asks.iter().take(5).map(|a| a.size).sum::<f64>();                                    let direction_str = match direction {                                        Direction::Up => "UP",                                        Direction::Down => "DOWN",                                    };                                    orderbook_share_prices.update_quote_with_depth(                                        asset,                                        tf,                                        direction_str,                                        bid,                                        ask,                                        midpoint,                                        bid_size,                                        ask_size,                                        depth_top5,                                    );                                }                            }                        }                    }                    if let Some(trade_side) = data.last_trade_side {                        let trade = crate::clob::types::Trade {                            id: format!("trade-{}", data.timestamp),                            order_id: ethers::types::H256::zero(),                            token_id: data.token_id.clone(),                            side: trade_side,                            price: data.last_price.unwrap_or(0.0),                            size: 0.0,                            timestamp: data.timestamp,                            taker: ethers::types::Address::zero(),                            maker: ethers::types::Address::zero(),                        };                        if let Ok(mut tracker) = orderbook_feed_tracker.lock() {                            if let Some((asset, tf, _)) = mapped {                                tracker.process_trade(&trade, asset, tf);                            }                        }                    }                }                WsEvent::Connected => {                    info!("üìä Polymarket orderbook WebSocket connected");                }                WsEvent::Disconnected => {                    warn!("üìä Polymarket orderbook WebSocket disconnected");                }                WsEvent::Error(e) => {                    error!(error = %e, "üìä Polymarket orderbook WebSocket error");                }                _ => {}            }        }        let _ = shutdown_tx.send(()).await;        let _ = client_handle.await;    });    // Spawn oracle sources (native mode = RTDS only, otherwise RTDS + optional Binance).    let oracle_event_tx = price_tx.clone();    let oracle_paper_tx = paper_price_tx.clone();    let oracle_paper_enabled = paper_trading_enabled;    let oracle_assets = config.bot.assets.clone();    let oracle_persistence = csv_persistence.clone();    let oracle_cfg = config.oracle.clone();    let polymarket_cfg = config.polymarket.clone();    let oracle_handle = tokio::spawn(async move {        use crate::oracle::sources::{BinanceClient, PriceSource as _, RtdsClient, SourceEvent};        use crate::persistence::PriceRecord;        let assets: Vec<Asset> = oracle_assets            .iter()            .filter_map(|s| Asset::from_str(s))            .collect();        let native_only = polymarket_cfg.data_mode.eq_ignore_ascii_case("native_only");        let enable_rtds = oracle_cfg.rtds_enabled && polymarket_cfg.rtds.enabled;        let enable_binance = oracle_cfg.binance_enabled && !native_only;        // Create event channel for oracle (shared between Binance and RTDS)        let (event_tx, mut event_rx) = mpsc::channel::<SourceEvent>(1000);        if !enable_binance && !enable_rtds {            tracing::warn!(                "No oracle source enabled; set oracle.rtds_enabled=true for native mode"            );            return;        }        // Spawn Binance connection only when native_only is disabled.        let binance_handle = if enable_binance {            let binance_tx = event_tx.clone();            let binance_assets = assets.clone();            Some(tokio::spawn(async move {                let mut client = BinanceClient::new();                if let Err(e) = client.subscribe(&binance_assets).await {                    tracing::error!(error = %e, "Binance subscribe failed");                    return;                }                if let Err(e) = client.connect(binance_tx).await {                    tracing::error!(error = %e, "Binance connection failed");                }            }))        } else {            tracing::info!("Binance feed disabled by polymarket.data_mode=native_only");            None        };        // Spawn RTDS connection (Polymarket feed).        let rtds_handle = if enable_rtds {            let rtds_tx = event_tx.clone();            let rtds_assets = assets.clone();            Some(tokio::spawn(async move {                let mut client = RtdsClient::new();                if let Err(e) = client.subscribe(&rtds_assets).await {                    tracing::error!(error = %e, "RTDS subscribe failed");                    return;                }                if let Err(e) = client.connect(rtds_tx).await {                    tracing::error!(error = %e, "RTDS connection failed");                }            }))        } else {            tracing::warn!("RTDS feed disabled; native Polymarket data will be unavailable");            None        };        let mut tick_count: u64 = 0;        // Process events and convert to PriceTicks        while let Some(event) = event_rx.recv().await {            match event {                SourceEvent::Tick(tick) => {                    tick_count += 1;                    if tick_count % 100 == 0 {                        tracing::info!(                            count = tick_count,                            asset = ?tick.asset,                            source = ?tick.source,                            "üìà Received price tick"                        );                    }                    let price_tick = PriceTick {                        exchange_ts: tick.ts,                        local_ts: chrono::Utc::now().timestamp_millis(),                        asset: tick.asset,                        bid: tick.bid,                        ask: tick.ask,                        mid: tick.mid,                        source: tick.source,                        latency_ms: tick.latency_ms as u64,                    };                    // Forward to paper trading engine if enabled                    if oracle_paper_enabled {                        let _ = oracle_paper_tx.send(price_tick.clone()).await;                    }                    if let Err(e) = oracle_event_tx.send(price_tick).await {                        tracing::error!(error = %e, "Failed to send price tick");                    }                    // Save price to CSV every 100 ticks (sampling)                    if tick_count % 100 == 0 {                        let record = PriceRecord {                            timestamp: tick.ts,                            asset: format!("{:?}", tick.asset),                            price: tick.mid,                            source: format!("{:?}", tick.source),                            volume: None,                        };                        if let Err(e) = oracle_persistence.save_price(record).await {                            tracing::warn!(error = %e, "Failed to save price to CSV");                        }                    }                }                SourceEvent::Connected(source) => {                    tracing::info!(source = %source, "üîå Oracle source connected");                }                SourceEvent::Disconnected(source) => {                    tracing::warn!(source = %source, "üîå Oracle source disconnected");                }                SourceEvent::Comment(comment) => {                    tracing::debug!(                        topic = %comment.topic,                        username = ?comment.username,                        symbol = ?comment.symbol,                        body = ?comment.body,                        "RTDS comment event received"                    );                }                SourceEvent::Error(source, err) => {                    tracing::error!(source = %source, error = %err, "Oracle error");                }                _ => {}            }        }        if let Some(handle) = binance_handle {            handle.abort();        }        if let Some(handle) = rtds_handle {            handle.abort();        }    });    // Feature engine task - processes price ticks and generates features    let feature_engine_inner = feature_engine.clone();    let feature_native_only = config        .polymarket        .data_mode        .eq_ignore_ascii_case("native_only");    let feature_clob_client = clob_client.clone();    let feature_data_dir = config.persistence.data_dir.clone();    let feature_handle = tokio::spawn(async move {        use crate::clob::PriceHistoryInterval;        use crate::oracle::sources::BinanceClient;        use crate::oracle::CandleBuilder;        use std::collections::HashMap;        let mut candle_builder = CandleBuilder::new(500);        let mut last_feature_time: HashMap<(Asset, Timeframe), i64> = HashMap::new();        let mut tick_count: u64 = 0;        // Fetch historical candles at startup only when native-only mode is disabled.        if !feature_native_only {            tracing::info!("Fetching historical candles from Binance...");            for asset in [Asset::BTC, Asset::ETH] {                for timeframe in [Timeframe::Min15, Timeframe::Hour1] {                    match BinanceClient::fetch_historical_candles(asset, timeframe, 100).await {                        Ok(candles) => {                            let count = candles.len();                            candle_builder.seed_history(candles);                            tracing::info!(                                asset = ?asset,                                timeframe = ?timeframe,                                candle_count = count,                                "Seeded historical candles"                            );                        }                        Err(e) => {                            tracing::warn!(                                asset = ?asset,                                timeframe = ?timeframe,                                error = %e,                                "Failed to fetch historical candles, will build from live data"                            );                        }                    }                }            }            tracing::info!("Historical candle fetch complete");        } else {            tracing::info!("Native-only mode: bootstrapping from Polymarket historical data");            if let Err(e) = feature_clob_client.refresh_markets().await {                tracing::warn!(                    error = %e,                    "Failed to refresh markets before Polymarket warmup bootstrap"                );            }            let native_targets: [(&str, Asset, Timeframe); 4] = [                ("btc-15m", Asset::BTC, Timeframe::Min15),                ("btc-1h", Asset::BTC, Timeframe::Hour1),                ("eth-15m", Asset::ETH, Timeframe::Min15),                ("eth-1h", Asset::ETH, Timeframe::Hour1),            ];            for (slug, asset, timeframe) in native_targets {                let local_points = load_local_price_points(&feature_data_dir, asset, 96);                let mut merged = build_candles_from_points(asset, timeframe, &local_points);                let local_count = merged.len();                let anchor = local_points                    .last()                    .map(|(_, price)| *price)                    .unwrap_or_else(|| default_anchor_price(asset));                if local_count < 30 {                    match bootstrap_polymarket_history_candles(                        feature_clob_client.as_ref(),                        slug,                        asset,                        timeframe,                        anchor,                        match timeframe {                            Timeframe::Min15 => PriceHistoryInterval::OneDay,                            Timeframe::Hour1 => PriceHistoryInterval::OneWeek,                        },                    )                    .await                    {                        Ok(mut candles) => {                            let remote_count = candles.len();                            if remote_count > 0 {                                merged.append(&mut candles);                                merged = dedup_candles_by_open_time(merged);                            }                            tracing::info!(                                market_slug = slug,                                asset = ?asset,                                timeframe = ?timeframe,                                local_candles = local_count,                                polymarket_candles = remote_count,                                total_candles = merged.len(),                                "Native warmup candles prepared"                            );                        }                        Err(e) => {                            tracing::warn!(                                market_slug = slug,                                asset = ?asset,                                timeframe = ?timeframe,                                local_candles = local_count,                                error = %e,                                "Failed to bootstrap Polymarket history for native warmup"                            );                        }                    }                } else {                    tracing::info!(                        market_slug = slug,                        asset = ?asset,                        timeframe = ?timeframe,                        local_candles = local_count,                        "Native warmup satisfied from local RTDS history"                    );                }                if !merged.is_empty() {                    let keep = 200usize;                    let mut seeded = merged;                    if seeded.len() > keep {                        seeded = seeded.split_off(seeded.len() - keep);                    }                    let seeded_count = seeded.len();                    candle_builder.seed_history(seeded);                    tracing::info!(                        market_slug = slug,                        asset = ?asset,                        timeframe = ?timeframe,                        seeded_candles = seeded_count,                        "Seeded native warmup candles"                    );                } else {                    tracing::warn!(                        market_slug = slug,                        asset = ?asset,                        timeframe = ?timeframe,                        "No historical candles available for native warmup"                    );                }            }        }        // Warmup indicators from seeded candles when available.        tracing::info!("Warming up FeatureEngine from historical candles...");        for asset in [Asset::BTC, Asset::ETH] {            for timeframe in [Timeframe::Min15, Timeframe::Hour1] {                let candles = candle_builder.get_last_n(asset, timeframe, 100);                let n = candles.len();                if n < 30 {                    tracing::warn!(                        asset = ?asset,                        timeframe = ?timeframe,                        candle_count = n,                        "Not enough historical candles for warmup (need 30+)"                    );                    continue;                }                // Progressively feed increasing slices to build stateful indicators.                let mut fe = feature_engine_inner.lock().await;                let start = 15.min(n);                for end in start..=n {                    let slice = &candles[..end];                    fe.compute(slice);                }                drop(fe);                tracing::info!(                    asset = ?asset,                    timeframe = ?timeframe,                    warmup_steps = n - start + 1,                    "FeatureEngine warmed up ({} candles replayed)",                    n                );            }        }        tracing::info!("FeatureEngine warmup complete");        while let Some(tick) = price_rx.recv().await {            tick_count += 1;            if tick_count % 100 == 0 {                tracing::debug!(count = tick_count, asset = ?tick.asset, "üîß Feature task received ticks");            }            // Convert PriceTick to NormalizedTick for candle builder            let normalized = crate::oracle::NormalizedTick {                ts: tick.exchange_ts,                asset: tick.asset,                bid: tick.bid,                ask: tick.ask,                mid: tick.mid,                source: tick.source,                latency_ms: tick.latency_ms as u64,            };            // Process each timeframe            for timeframe in [Timeframe::Min15, Timeframe::Hour1] {                // Add tick to candle builder for this timeframe                candle_builder.add_tick(&normalized, timeframe);                // Get candles (returns Vec<Candle>, not Option)                let candles = candle_builder.get_last_n(tick.asset, timeframe, 50);                let candle_count = candles.len();                // Log candle count periodically (every 10 seconds per asset/timeframe)                let now = chrono::Utc::now().timestamp_millis();                let key = (tick.asset, timeframe);                let last = last_feature_time.entry(key).or_insert(0);                if now - *last > 10000 {                    *last = now;                    tracing::info!(                        asset = ?tick.asset,                        timeframe = ?timeframe,                        candle_count = candle_count,                        "üïØÔ∏è Candle count"                    );                }                // Need at least 30 candles for meaningful technical indicators                if candle_count >= 30 {                    if let Some(features) = feature_engine_inner.lock().await.compute(&candles) {                        // Log features at DEBUG level to avoid log spam                        if features.rsi.is_some() || features.macd.is_some() {                            tracing::debug!(                                asset = ?tick.asset,                                timeframe = ?timeframe,                                rsi = ?features.rsi,                                macd = ?features.macd,                                momentum = ?features.momentum,                                trend = ?features.trend_strength,                                "üìä Features computed"                            );                            // Send Features directly to strategy                            if let Err(e) = feature_tx.send(features).await {                                tracing::error!(error = %e, "Failed to send features");                            }                        }                    }                }            }        }    });    // Strategy engine task - processes features and generates signals    let strategy_inner = strategy.clone();    let strategy_persistence = csv_persistence.clone();    let strategy_client = clob_client.clone(); // For market lookup    let strategy_risk = risk_manager.clone(); // For position sizing    let strategy_kelly_cfg = config.kelly.clone();    #[cfg(feature = "dashboard")]    let strategy_dashboard_memory = dashboard_memory.clone();    #[cfg(feature = "dashboard")]    let strategy_dashboard_broadcaster = dashboard_broadcaster.clone();    // Circuit breaker: track last feature timestamp per asset    let last_feature_ts: std::sync::Arc<tokio::sync::Mutex<std::collections::HashMap<Asset, i64>>> =        std::sync::Arc::new(tokio::sync::Mutex::new(std::collections::HashMap::new()));    let last_feature_ts_clone = last_feature_ts.clone();    let strategy_handle = tokio::spawn(async move {        use crate::persistence::SignalRecord;        use crate::polymarket::{            compute_fractional_kelly, estimate_expected_value, fee_rate_from_price,        };        while let Some(features) = feature_rx.recv().await {            // ‚îÄ‚îÄ CIRCUIT BREAKER: Check for stale price data ‚îÄ‚îÄ            let now = chrono::Utc::now().timestamp_millis();            {                let mut ts_map = last_feature_ts_clone.lock().await;                let last_ts = ts_map.get(&features.asset).copied().unwrap_or(0);                ts_map.insert(features.asset, now);                // If last feature was more than 60 seconds ago, we had a gap                if last_ts > 0 && now - last_ts > 60_000 {                    tracing::warn!(                        asset = ?features.asset,                        gap_ms = now - last_ts,                        "‚ö†Ô∏è Price data gap detected - skipping signal generation"                    );                    continue;                }            }            // Process features and potentially generate signal (using global strategy for calibration)            if let Some(signal) = strategy_inner.lock().await.process(&features) {                tracing::info!(                    asset = ?signal.asset,                    direction = ?signal.direction,                    confidence = %signal.confidence,                    reasons = ?signal.reasons,                    "üéØ Signal generated!"                );                // Save signal to CSV                let record = SignalRecord {                    timestamp: signal.ts,                    market_id: format!("{:?}-{:?}", signal.asset, signal.timeframe),                    direction: format!("{:?}", signal.direction),                    confidence: signal.confidence,                    entry_price: 0.0, // Will be set on execution                    features_hash: format!(                        "rsi:{:.2}_macd:{:.2}",                        features.rsi.unwrap_or(0.0),                        features.macd.unwrap_or(0.0)                    ),                };                if let Err(e) = strategy_persistence.save_signal(record).await {                    tracing::warn!(error = %e, "Failed to save signal to CSV");                }                // Convert Features to FeatureSet for Signal                let regime_i8 = match features.regime {                    MarketRegime::Trending => 1,                    MarketRegime::Ranging => 0,                    MarketRegime::Volatile => -1,                };                let feature_set = FeatureSet {                    ts: features.ts,                    asset: features.asset,                    timeframe: features.timeframe,                    rsi: features.rsi.unwrap_or(50.0),                    macd_line: features.macd.unwrap_or(0.0),                    macd_signal: features.macd_signal.unwrap_or(0.0),                    macd_hist: features.macd_hist.unwrap_or(0.0),                    vwap: features.vwap.unwrap_or(0.0),                    bb_upper: features.bb_upper.unwrap_or(0.0),                    bb_lower: features.bb_lower.unwrap_or(0.0),                    atr: features.atr.unwrap_or(0.0),                    momentum: features.momentum.unwrap_or(0.0),                    momentum_accel: features.velocity.unwrap_or(0.0),                    book_imbalance: 0.0,                    spread_bps: 0.0,                    trade_intensity: 0.0,                    ha_close: features.ha_close.unwrap_or(0.0),                    ha_trend: features                        .ha_trend                        .map(|d| if d == Direction::Up { 1 } else { -1 })                        .unwrap_or(0) as i8,                    oracle_confidence: 1.0,                    adx: features.adx.unwrap_or(0.0),                    stoch_rsi: features.stoch_rsi.unwrap_or(0.5),                    obv: features.obv.unwrap_or(0.0),                    relative_volume: features.relative_volume.unwrap_or(1.0),                    regime: regime_i8,                };                // Look up market for this asset/timeframe to get expiry and token info                let selected_market = match strategy_client                    .find_tradeable_market_for_signal(signal.asset, signal.timeframe)                    .await                {                    Some(market) => market,                    None => {                        tracing::warn!(                            asset = ?signal.asset,                            timeframe = ?signal.timeframe,                            "Skipping signal: no tradeable market found"                        );                        #[cfg(feature = "dashboard")]                        strategy_dashboard_memory                            .record_execution_rejection("market_not_found")                            .await;                        continue;                    }                };                let market_slug = selected_market                    .slug                    .clone()                    .unwrap_or_else(|| selected_market.question.clone());                let condition_id = selected_market.condition_id.clone();                let expires_at = selected_market                    .end_date                    .as_ref()                    .and_then(|d| crate::clob::ClobClient::parse_expiry_to_timestamp(d))                    .or_else(|| {                        selected_market                            .end_date_iso                            .as_ref()                            .and_then(|d| crate::clob::ClobClient::parse_expiry_to_timestamp(d))                    })                    .unwrap_or(0);                let token_id = crate::clob::ClobClient::resolve_token_id_for_direction(                    &selected_market,                    signal.direction,                )                .unwrap_or_default();                if token_id.is_empty() {                    tracing::warn!(                        market_slug = %market_slug,                        direction = ?signal.direction,                        "Skipping signal: token_id not found for market direction"                    );                    #[cfg(feature = "dashboard")]                    strategy_dashboard_memory                        .record_execution_rejection("token_not_found")                        .await;                    continue;                }                // Convert to Signal type using Polymarket-native EV + Kelly sizing.                let quote = match strategy_client.quote_token(&token_id).await {                    Ok(q) if q.bid > 0.0 && q.ask > 0.0 && q.mid > 0.0 => q,                    Ok(_) => {                        tracing::warn!(                            market_slug = %market_slug,                            token_id = %token_id,                            "Skipping signal: invalid quote values"                        );                        #[cfg(feature = "dashboard")]                        strategy_dashboard_memory                            .record_execution_rejection("quote_invalid")                            .await;                        continue;                    }                    Err(e) => {                        tracing::warn!(                            market_slug = %market_slug,                            token_id = %token_id,                            error = %e,                            "Skipping signal: failed to fetch token quote"                        );                        #[cfg(feature = "dashboard")]                        strategy_dashboard_memory                            .record_execution_rejection("quote_fetch_error")                            .await;                        continue;                    }                };                let p_market = quote.mid.clamp(0.01, 0.99);                let spread = quote.spread.max(0.0);                let max_spread = match signal.timeframe {                    Timeframe::Min15 => 0.03,                    Timeframe::Hour1 => 0.05,                };                if spread > max_spread {                    tracing::info!(                        market_slug = %market_slug,                        token_id = %token_id,                        spread = spread,                        max_spread = max_spread,                        "Skipping signal: spread too wide for timeframe policy"                    );                    #[cfg(feature = "dashboard")]                    strategy_dashboard_memory                        .record_execution_rejection("spread_too_wide")                        .await;                    continue;                }                let min_depth_top5 = match signal.timeframe {                    Timeframe::Min15 => 50.0,                    Timeframe::Hour1 => 25.0,                };                if quote.depth_top5 > 0.0 && quote.depth_top5 < min_depth_top5 {                    tracing::info!(                        market_slug = %market_slug,                        token_id = %token_id,                        depth_top5 = quote.depth_top5,                        min_depth_top5 = min_depth_top5,                        "Skipping signal: depth below liquidity policy"                    );                    #[cfg(feature = "dashboard")]                    strategy_dashboard_memory                        .record_execution_rejection("depth_too_low")                        .await;                    continue;                }                let p_model = signal.confidence.clamp(0.01, 0.99);                let fee_rate = fee_rate_from_price(p_market);                let ev =                    estimate_expected_value(p_market, p_model, p_market, fee_rate, spread, 0.005);                if ev.edge_net <= 0.0 {                    tracing::info!(                        market_slug = %market_slug,                        p_market = p_market,                        p_model = p_model,                        edge_net = ev.edge_net,                        "Skipping signal due to non-positive Polymarket edge"                    );                    #[cfg(feature = "dashboard")]                    strategy_dashboard_memory                        .record_execution_rejection("edge_non_positive")                        .await;                    continue;                }                let (kelly_fraction, cap) = match signal.timeframe {                    Timeframe::Min15 => (                        strategy_kelly_cfg.fraction_15m,                        strategy_kelly_cfg.max_bankroll_fraction_15m,                    ),                    Timeframe::Hour1 => (                        strategy_kelly_cfg.fraction_1h,                        strategy_kelly_cfg.max_bankroll_fraction_1h,                    ),                };                let kelly = compute_fractional_kelly(p_model, 0.05, p_market, kelly_fraction, cap);                let fallback_size = strategy_risk.calculate_size_from_confidence(signal.confidence);                let balance = strategy_risk.get_balance();                let bankroll = if balance > 0.0 { balance } else { 1000.0 };                let kelly_size = bankroll * kelly.f_fractional;                let calculated_size = if strategy_kelly_cfg.enabled && kelly_size >= 1.0 {                    kelly_size                } else {                    fallback_size                };                let sig = Signal {                    id: uuid::Uuid::new_v4().to_string(),                    ts: signal.ts,                    asset: signal.asset,                    timeframe: signal.timeframe,                    direction: signal.direction,                    confidence: signal.confidence,                    features: feature_set,                    strategy_id: "rules_v1".to_string(),                    market_slug,                    condition_id,                    token_id,                    expires_at,                    suggested_size_usdc: calculated_size,                    indicators_used: signal.indicators_used,                };                #[cfg(feature = "dashboard")]                let dashboard_signal = crate::dashboard::SignalResponse {                    timestamp: sig.ts,                    signal_id: sig.id.clone(),                    asset: format!("{:?}", sig.asset),                    timeframe: format!("{}", sig.timeframe),                    direction: format!("{:?}", sig.direction),                    confidence: sig.confidence,                    entry_price: 0.0,                    market_slug: sig.market_slug.clone(),                    expires_at: sig.expires_at,                };                if let Err(e) = signal_tx.send(sig).await {                    tracing::error!(error = %e, "Failed to send signal");                    #[cfg(feature = "dashboard")]                    strategy_dashboard_memory                        .record_execution_rejection("signal_channel_send_error")                        .await;                } else {                    #[cfg(feature = "dashboard")]                    {                        strategy_dashboard_memory                            .record_execution_accept()                            .await;                        strategy_dashboard_memory.add_signal(dashboard_signal.clone()).await;                        strategy_dashboard_broadcaster.broadcast_signal(dashboard_signal);                    }                }            }        }    });    // Order execution task - consumes order_rx and submits to Polymarket    let execution_client = clob_client.clone();    let execution_handle = tokio::spawn(async move {        if let Err(e) = execution_client.run(order_rx).await {            error!(error = %e, "Execution client task failed");        }    });    // ‚îÄ‚îÄ Live position ‚Üí indicators tracking (for calibration in live mode) ‚îÄ‚îÄ    // When a live signal is executed, we store which indicators generated it.    // When the position closes (detected by position monitor), we use this to    // feed back into the calibrator ‚Äî so the brain learns from live trades too.    let live_position_indicators: Arc<        Mutex<std::collections::HashMap<(Asset, Timeframe), (Vec<String>, f64)>>,    > = Arc::new(Mutex::new(std::collections::HashMap::new()));    let live_indicators_for_monitor = live_position_indicators.clone();    let live_indicators_for_main = live_position_indicators.clone();    let live_window_bias: Arc<        Mutex<std::collections::HashMap<(Asset, Timeframe, i64), Direction>>,    > = Arc::new(Mutex::new(std::collections::HashMap::new()));    // Strategy + calibrator state path for live calibration saving    let strategy_for_live_calibration = strategy.clone();    let calibrator_save_path_live = calibrator_state_file_v2.clone();    // Position monitoring task - fetches wallet positions for TP/SL    let position_client = clob_client.clone();    let position_risk = risk_manager.clone();    let position_tracker = balance_tracker.clone();    let redeemed_claims = Arc::new(tokio::sync::Mutex::new(        std::collections::HashSet::<String>::new(),    ));    let redeemed_claims_for_monitor = redeemed_claims.clone();    let wallet_address = std::env::var("POLYMARKET_WALLET")        .ok()        .or_else(|| std::env::var("POLYMARKET_ADDRESS").ok())        .unwrap_or_default();    let position_handle = tokio::spawn(async move {        let mut interval = tokio::time::interval(tokio::time::Duration::from_secs(30));        loop {            interval.tick().await;            if wallet_address.is_empty() {                continue;            }            match position_client                .fetch_wallet_positions(&wallet_address)                .await            {                Ok(positions) => {                    for pos in positions {                        // Parse position size                        let size: f64 = pos.size.parse().unwrap_or(0.0);                        if size == 0.0 {                            continue;                        }                        let avg_price: f64 = pos.avg_price.parse().unwrap_or(0.0);                        let current_price: f64 = pos                            .current_price                            .as_ref()                            .and_then(|p| p.parse().ok())                            .unwrap_or(avg_price);                        // Try to parse asset from position                        let asset_str = pos.asset.to_uppercase();                        let asset = if asset_str.contains("BTC") {                            Some(Asset::BTC)                        } else if asset_str.contains("ETH") {                            Some(Asset::ETH)                        } else if asset_str.contains("SOL") {                            Some(Asset::SOL)                        } else if asset_str.contains("XRP") {                            Some(Asset::XRP)                        } else {                            None                        };                        // Update risk manager with position (only if we can identify the asset)                        if let Some(asset) = asset {                            if let Some(exit_reason) =                                position_risk.update_position(asset, current_price)                            {                                tracing::warn!(                                    asset = ?asset,                                    reason = ?exit_reason,                                    current_price = current_price,                                    "üö® Position should be closed!"                                );                                // Calculate PnL for this position                                // For a LONG: pnl = (current_price - avg_price) * size                                // For a SHORT: pnl = (avg_price - current_price) * size                                // Assuming we're always LONG for prediction markets                                let pnl = (current_price - avg_price) * size;                                let internal_result = if pnl >= 0.0 { "WIN" } else { "LOSS" };                                // Create win/loss record                                use crate::persistence::WinLossRecord;                                let token_id =                                    pos.token_id.clone().unwrap_or_else(|| pos.asset.clone());                                let official_result =                                    if let Some(condition_id) = pos.condition_id.as_deref() {                                        position_client                                            .official_result_for_token(condition_id, &token_id)                                            .await                                    } else {                                        None                                    };                                if official_result.as_deref() == Some("WIN") {                                    if let Some(condition_id) = pos.condition_id.as_deref() {                                        let redeem_key = format!("{}:{}", condition_id, token_id);                                        let should_attempt = {                                            let mut redeemed =                                                redeemed_claims_for_monitor.lock().await;                                            redeemed.insert(redeem_key.clone())                                        };                                        if should_attempt {                                            if let Err(e) = position_client                                                .redeem_winning_tokens(                                                    condition_id,                                                    &token_id,                                                    size,                                                )                                                .await                                            {                                                tracing::warn!(                                                    error = %e,                                                    condition_id = %condition_id,                                                    token_id = %token_id,                                                    "Redemption attempt failed"                                                );                                                redeemed_claims_for_monitor                                                    .lock()                                                    .await                                                    .remove(&redeem_key);                                            }                                        }                                    }                                }                                let record = WinLossRecord {                                    timestamp: chrono::Utc::now().timestamp(),                                    market_slug: format!("{:?}", asset),                                    token_id,                                    entry_price: avg_price,                                    exit_price: current_price,                                    size,                                    pnl,                                    internal_result: internal_result.to_string(),                                    exit_reason: exit_reason.to_string(),                                    official_result,                                };                                // Record win/loss in balance tracker                                position_tracker.record_winloss(record);                                // ‚îÄ‚îÄ LIVE CALIBRATION: Train the brain from live trade results ‚îÄ‚îÄ                                // Look up which indicators generated this position's signal                                let parsed_timeframe = parse_timeframe_from_market_text(&pos.asset);                                let (timeframe, indicators, p_model) = {                                    let mut pending = live_indicators_for_monitor.lock().await;                                    if let Some(tf) = parsed_timeframe {                                        pending                                            .remove(&(asset, tf))                                            .map(|ctx| (tf, ctx.0, ctx.1))                                            .unwrap_or((tf, Vec::new(), 0.5))                                    } else {                                        let keys: Vec<(Asset, Timeframe)> = pending                                            .keys()                                            .copied()                                            .filter(|(a, _)| *a == asset)                                            .collect();                                        if keys.len() == 1 {                                            let key = keys[0];                                            let (inds, p_model) =                                                pending.remove(&key).unwrap_or((Vec::new(), 0.5));                                            (key.1, inds, p_model)                                        } else {                                            if keys.len() > 1 {                                                tracing::warn!(                                                    asset = ?asset,                                                    candidates = keys.len(),                                                    "Ambiguous live calibration context; skipping feedback"                                                );                                            }                                            (Timeframe::Min15, Vec::new(), 0.5)                                        }                                    }                                };                                if !indicators.is_empty() {                                    let is_win = pnl >= 0.0;                                    let result = if is_win {                                        TradeResult::Win                                    } else {                                        TradeResult::Loss                                    };                                    let mut strat = strategy_for_live_calibration.lock().await;                                    strat.record_trade_with_indicators_for_market(                                        asset,                                        timeframe,                                        &indicators,                                        result,                                    );                                    strat.record_prediction_outcome_for_market(                                        asset, timeframe, p_model, is_win,                                    );                                    // Save calibrator state to disk                                    let stats = strat.export_calibrator_state_v2();                                    let total = strat.calibrator_total_trades();                                    let calibrated = strat.is_calibrated();                                    drop(strat);                                    if let Ok(json) = serde_json::to_string_pretty(&stats) {                                        if let Err(e) =                                            std::fs::write(&calibrator_save_path_live, &json)                                        {                                            tracing::warn!(error = %e, "Failed to save calibrator state (live)");                                        }                                    }                                    tracing::info!(                                        asset = ?asset,                                        timeframe = ?timeframe,                                        is_win = is_win,                                        p_model = p_model,                                        indicators_count = indicators.len(),                                        total_trades = total,                                        calibrated = calibrated,                                        "üß† [LIVE CALIBRATION] Trade result recorded & saved"                                    );                                }                                tracing::info!(                                    asset = ?asset,                                    pnl = pnl,                                    result = internal_result,                                    "üìä Win/Loss recorded"                                );                                // In a real implementation, this would trigger a close order                            }                        }                        tracing::info!(                            asset = %pos.asset,                            size = size,                            avg_price = avg_price,                            current = current_price,                            "üìä Position tracked"                        );                    }                }                Err(e) => {                    tracing::warn!(error = %e, "Failed to fetch wallet positions");                }            }        }    });    // Balance tracking task - fetches balance periodically and updates trackers    let balance_client = clob_client.clone();    let balance_tracker_clone = balance_tracker.clone();    let balance_risk = risk_manager.clone();    let balance_wallet_address = std::env::var("POLYMARKET_WALLET")        .ok()        .or_else(|| std::env::var("POLYMARKET_ADDRESS").ok())        .unwrap_or_default();    let balance_handle = tokio::spawn(async move {        let mut interval = tokio::time::interval(tokio::time::Duration::from_secs(60));        let mut initialized = false;        loop {            interval.tick().await;            // Fetch balance from Polymarket            match balance_client.get_balance().await {                Ok(balance) => {                    tracing::info!(balance_usdc = balance, "üí∞ Balance fetched");                    // Initialize balance tracker on first fetch                    if !initialized {                        balance_tracker_clone.initialize(balance);                        initialized = true;                        tracing::info!(initial_balance = balance, "üèÅ Balance tracker initialized");                    }                    let locked_in_positions = if !balance_wallet_address.is_empty() {                        match balance_client                            .fetch_wallet_positions(&balance_wallet_address)                            .await                        {                            Ok(positions) => positions                                .iter()                                .map(|p| {                                    let size = p.size.parse::<f64>().unwrap_or(0.0).max(0.0);                                    let price = p                                        .current_price                                        .as_ref()                                        .and_then(|v| v.parse::<f64>().ok())                                        .unwrap_or_else(|| {                                            p.avg_price.parse::<f64>().unwrap_or(0.0)                                        })                                        .clamp(0.0, 1.0);                                    size * price                                })                                .sum::<f64>(),                            Err(e) => {                                tracing::warn!(                                    error = %e,                                    "Failed to fetch wallet positions for locked-balance estimate"                                );                                0.0                            }                        }                    } else {                        0.0                    };                    // Update balance tracker                    balance_tracker_clone.update_balance(                        balance, // available                        locked_in_positions,                    );                    // Update risk manager                    balance_risk.set_balance(balance);                }                Err(e) => {                    tracing::warn!(error = %e, "Failed to fetch balance");                }            }        }    });    // ‚îÄ‚îÄ Orderbook sync task - periodically sync tracker to feature engine ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ    let orderbook_sync_tracker = orderbook_tracker.clone();    let orderbook_sync_feature = feature_engine.clone();    #[cfg(feature = "dashboard")]    let orderbook_sync_dashboard = dashboard_memory.clone();    let orderbook_sync_strategy = strategy.clone();    let orderbook_sync_handle = tokio::spawn(async move {        let mut interval = tokio::time::interval(tokio::time::Duration::from_secs(5));        loop {            interval.tick().await;            // Update feature engine with latest orderbook data            for asset in [Asset::BTC, Asset::ETH] {                for timeframe in [Timeframe::Min15, Timeframe::Hour1] {                    orderbook_sync_feature                        .lock()                        .await                        .update_from_tracker(asset, timeframe);                }            }            // Update dashboard with indicator stats            #[cfg(feature = "dashboard")]            {                let strat = orderbook_sync_strategy.lock().await;                let indicator_stats = strat.get_indicator_stats();                let market_learning = strat.export_calibrator_state_v2();                let calibration_quality = strat.export_calibration_quality_by_market();                drop(strat);                *orderbook_sync_dashboard.indicator_stats.write().await = indicator_stats;                orderbook_sync_dashboard                    .set_market_learning_stats(market_learning)                    .await;                orderbook_sync_dashboard                    .set_calibration_quality_stats(calibration_quality)                    .await;            }        }    });    // Paper trading: price monitor task (feeds ticks to paper engine for position tracking)    let paper_monitor_engine = paper_engine.clone();    #[cfg(feature = "dashboard")]    let paper_dashboard_memory = dashboard_memory.clone();    #[cfg(feature = "dashboard")]    let paper_dashboard_broadcaster = dashboard_broadcaster.clone();    #[cfg(feature = "dashboard")]    let paper_csv_persistence = csv_persistence.clone();    // Clone for main loop (paper_monitor_handle takes ownership of paper_dashboard_broadcaster)    #[cfg(feature = "dashboard")]    let main_loop_broadcaster = dashboard_broadcaster.clone();    let main_loop_share_prices = polymarket_share_prices.clone();    let paper_monitor_handle = if paper_trading_enabled {        let engine = paper_monitor_engine.unwrap();        #[cfg(feature = "dashboard")]        let csv_persistence_for_backfill = paper_csv_persistence.clone();        #[cfg(feature = "dashboard")]        let mut last_price_broadcast: i64 = 0;        #[cfg(feature = "dashboard")]        const PRICE_BROADCAST_INTERVAL_MS: i64 = 1000; // Broadcast prices every 1 second max        #[cfg(feature = "dashboard")]        let mut last_trade_backfill_ms: i64 = 0;        #[cfg(feature = "dashboard")]        const TRADE_BACKFILL_INTERVAL_MS: i64 = 30_000; // Rehydrate trades from CSV every 30s if empty        Some(tokio::spawn(async move {            while let Some(tick) = paper_price_rx.recv().await {                // Update the paper engine with the new price                let exits = engine.update_price(tick.asset, tick.mid, tick.source);                #[cfg(feature = "dashboard")]                let mut closed_trades: Vec<TradeResponse> = Vec::new();                // Close any positions that hit exit conditions (with full analytics)                let had_exits = !exits.is_empty();                for ((asset, timeframe), reason) in exits {                    if let Some(record) = engine.close_and_save(asset, timeframe, reason).await {                        #[cfg(feature = "dashboard")]                        closed_trades.push(paper_trade_record_to_dashboard_trade(&record));                    }                }                // Broadcast position updates if any positions were closed                #[cfg(feature = "dashboard")]                if had_exits {                    for trade in &closed_trades {                        paper_dashboard_memory.add_trade(trade.clone()).await;                        paper_dashboard_broadcaster.broadcast_trade(trade.clone());                    }                    let positions: Vec<PositionResponse> = engine                        .get_positions()                        .into_iter()                        .map(|p| PositionResponse {                            id: p.id.clone(),                            asset: format!("{:?}", p.asset),                            timeframe: format!("{:?}", p.timeframe),                            direction: format!("{:?}", p.direction),                            entry_price: p.entry_price,                            current_price: p.current_price,                            size_usdc: p.size_usdc,                            pnl: p.unrealized_pnl,                            pnl_pct: if p.entry_price > 0.0 {                                ((p.current_price - p.entry_price) / p.entry_price * 100.0)                                    * if p.direction == Direction::Up {                                        1.0                                    } else {                                        -1.0                                    }                            } else {                                0.0                            },                            opened_at: p.opened_at,                            market_slug: p.market_slug.clone(),                            confidence: p.confidence,                            peak_price: p.peak_price,                            trough_price: p.trough_price,                            market_close_ts: p.market_close_ts,                            time_remaining_secs: ((p.market_close_ts                                - chrono::Utc::now().timestamp_millis())                                / 1000)                                .max(0),                        })                        .collect();                    *paper_dashboard_memory.paper_positions.write().await = positions.clone();                    paper_dashboard_broadcaster.broadcast_positions(positions.clone());                    // Broadcast stats immediately after position closed                    let stats = engine.get_stats();                    let balance = engine.get_balance();                    let locked = engine.get_locked_balance();                    let equity = engine.get_total_equity();                    let stats_response = PaperStatsResponse {                        total_trades: stats.total_trades,                        wins: stats.wins,                        losses: stats.losses,                        win_rate: if stats.total_trades > 0 {                            (stats.wins as f64 / stats.total_trades as f64) * 100.0                        } else {                            0.0                        },                        total_pnl: stats.total_pnl,                        total_fees: stats.total_fees,                        largest_win: stats.largest_win,                        largest_loss: stats.largest_loss,                        avg_win: if stats.wins > 0 {                            stats.sum_win_pnl / stats.wins as f64                        } else {                            0.0                        },                        avg_loss: if stats.losses > 0 {                            stats.sum_loss_pnl / stats.losses as f64                        } else {                            0.0                        },                        max_drawdown: stats.max_drawdown,                        current_drawdown: {                            let peak = stats.peak_balance;                            if peak > 0.0 {                                ((peak - equity) / peak * 100.0).max(0.0)                            } else {                                0.0                            }                        },                        peak_balance: stats.peak_balance,                        profit_factor: if stats.gross_loss > 0.0 {                            stats.gross_profit / stats.gross_loss                        } else if stats.gross_profit > 0.0 {                            f64::INFINITY                        } else {                            0.0                        },                        current_streak: stats.current_streak,                        best_streak: stats.best_streak,                        worst_streak: stats.worst_streak,                        exits_trailing_stop: stats.exits_trailing_stop,                        exits_take_profit: stats.exits_take_profit,                        exits_market_expiry: stats.exits_market_expiry,                        exits_time_expiry: stats.exits_time_expiry,                    };                    paper_dashboard_broadcaster.broadcast_stats(stats_response);                }                // Periodically print dashboard                engine.maybe_print_dashboard();                // ‚îÄ‚îÄ Update Dashboard API ‚îÄ‚îÄ                #[cfg(feature = "dashboard")]                {                    use crate::dashboard::{PaperStatsResponse, PositionResponse};                    // Update price in dashboard                    paper_dashboard_memory                        .update_price_at(                            tick.asset,                            tick.mid,                            tick.bid,                            tick.ask,                            tick.source,                            tick.exchange_ts,                        )                        .await;                    // Update paper trading state                    let stats = engine.get_stats();                    let balance = engine.get_balance();                    let locked = engine.get_locked_balance();                    let equity = engine.get_total_equity();                    let unrealized = equity - balance - locked;                    // Update dashboard memory                    *paper_dashboard_memory.paper_balance.write().await = balance;                    *paper_dashboard_memory.paper_locked.write().await = locked;                    *paper_dashboard_memory.paper_unrealized_pnl.write().await = unrealized;                    // Convert stats to response type                    let stats_response = PaperStatsResponse {                        total_trades: stats.total_trades,                        wins: stats.wins,                        losses: stats.losses,                        win_rate: if stats.total_trades > 0 {                            (stats.wins as f64 / stats.total_trades as f64) * 100.0                        } else {                            0.0                        },                        total_pnl: stats.total_pnl,                        total_fees: stats.total_fees,                        largest_win: stats.largest_win,                        largest_loss: stats.largest_loss,                        avg_win: if stats.wins > 0 {                            stats.sum_win_pnl / stats.wins as f64                        } else {                            0.0                        },                        avg_loss: if stats.losses > 0 {                            stats.sum_loss_pnl / stats.losses as f64                        } else {                            0.0                        },                        max_drawdown: stats.max_drawdown,                        current_drawdown: {                            let peak = stats.peak_balance;                            if peak > 0.0 {                                ((peak - equity) / peak * 100.0).max(0.0)                            } else {                                0.0                            }                        },                        peak_balance: stats.peak_balance,                        profit_factor: if stats.gross_loss > 0.0 {                            stats.gross_profit / stats.gross_loss                        } else if stats.gross_profit > 0.0 {                            f64::INFINITY                        } else {                            0.0                        },                        current_streak: stats.current_streak,                        best_streak: stats.best_streak,                        worst_streak: stats.worst_streak,                        exits_trailing_stop: stats.exits_trailing_stop,                        exits_take_profit: stats.exits_take_profit,                        exits_market_expiry: stats.exits_market_expiry,                        exits_time_expiry: stats.exits_time_expiry,                    };                    *paper_dashboard_memory.paper_stats.write().await = stats_response.clone();                    // Update positions                    let positions: Vec<PositionResponse> = engine                        .get_positions()                        .into_iter()                        .map(|p| PositionResponse {                            id: p.id.clone(),                            asset: format!("{:?}", p.asset),                            timeframe: format!("{:?}", p.timeframe),                            direction: format!("{:?}", p.direction),                            entry_price: p.entry_price,                            current_price: p.current_price,                            size_usdc: p.size_usdc,                            pnl: p.unrealized_pnl,                            pnl_pct: if p.entry_price > 0.0 {                                ((p.current_price - p.entry_price) / p.entry_price * 100.0)                                    * if p.direction == Direction::Up {                                        1.0                                    } else {                                        -1.0                                    }                            } else {                                0.0                            },                            opened_at: p.opened_at,                            market_slug: p.market_slug.clone(),                            confidence: p.confidence,                            peak_price: p.peak_price,                            trough_price: p.trough_price,                            market_close_ts: p.market_close_ts,                            time_remaining_secs: ((p.market_close_ts                                - chrono::Utc::now().timestamp_millis())                                / 1000)                                .max(0),                        })                        .collect();                    *paper_dashboard_memory.paper_positions.write().await = positions.clone();                    // Safety net: if dashboard started before CSV had data, rehydrate recent trades from CSV.                    let now = chrono::Utc::now().timestamp_millis();                    if now - last_trade_backfill_ms >= TRADE_BACKFILL_INTERVAL_MS {                        last_trade_backfill_ms = now;                        let trades_empty =                            paper_dashboard_memory.paper_trades.read().await.is_empty();                        if trades_empty {                            match csv_persistence_for_backfill.load_recent_paper_trades(10_000) {                                Ok(backfilled) if !backfilled.is_empty() => {                                    let loaded = backfilled.len();                                    paper_dashboard_memory.set_paper_trades(backfilled).await;                                    tracing::info!(                                        loaded_trades = loaded,                                        "Dashboard recent_trades rehydrated from CSV"                                    );                                }                                Ok(_) => {}                                Err(e) => {                                    tracing::warn!(error = %e, "Failed to backfill dashboard recent_trades from CSV");                                }                            }                        }                    }                    // Broadcast price update (throttled to prevent UI flickering)                    if now - last_price_broadcast >= PRICE_BROADCAST_INTERVAL_MS {                        last_price_broadcast = now;                        paper_dashboard_broadcaster                            .broadcast_prices(paper_dashboard_memory.get_prices().await.prices);                        paper_dashboard_broadcaster.broadcast_positions(positions.clone());                        // Also broadcast stats for real-time dashboard updates                        paper_dashboard_broadcaster.broadcast_stats(stats_response);                    }                }            }        }))    } else {        // Drain the channel so it doesn't block        tokio::spawn(async move { while paper_price_rx.recv().await.is_some() {} });        None    };    // Main loop: process signals through risk manager and execute    info!("üéØ Entering main trading loop...");    loop {        tokio::select! {            // Process incoming signals            Some(signal) = signal_rx.recv() => {                let signal_id = signal.id.clone();                // ‚îÄ‚îÄ Paper Trading path ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ                if paper_trading_enabled {                    if let Some(ref engine) = paper_engine {                        // Apply risk checks (still use risk manager for signal quality)                        match risk_manager.evaluate(&signal) {                            Ok(approved) => {                                if approved {                                    info!(                                        signal_id = %signal_id,                                        asset = %signal.asset,                                        direction = ?signal.direction,                                        confidence = %signal.confidence,                                        "üìã [PAPER] Signal approved"                                    );                                    if !signal.token_id.trim().is_empty() {                                        match clob_client.quote_token(&signal.token_id).await {                                            Ok(q) if q.bid > 0.0 && q.ask > 0.0 && q.mid > 0.0 => {                                                let direction_str = match signal.direction {                                                    Direction::Up => "UP",                                                    Direction::Down => "DOWN",                                                };                                                main_loop_share_prices.update_quote_with_depth(                                                    signal.asset,                                                    signal.timeframe,                                                    direction_str,                                                    q.bid,                                                    q.ask,                                                    q.mid,                                                    q.bid_size,                                                    q.ask_size,                                                    q.depth_top5,                                                );                                            }                                            Ok(_) => {                                                warn!(                                                    signal_id = %signal_id,                                                    token_id = %signal.token_id,                                                    "Paper pre-execution quote invalid; keeping existing quote state"                                                );                                            }                                            Err(e) => {                                                warn!(                                                    signal_id = %signal_id,                                                    token_id = %signal.token_id,                                                    error = %e,                                                    "Paper pre-execution quote fetch failed; keeping existing quote state"                                                );                                            }                                        }                                    }                                    match engine.execute_signal(&signal) {                                        Ok(true) => {                                            info!(signal_id = %signal_id, "üìã [PAPER] Order filled");                                            // Broadcast position opened for real-time dashboard updates                                            #[cfg(feature = "dashboard")]                                            {                                                use crate::dashboard::PositionResponse;                                                // Get the newly opened position and broadcast it                                                if let Some(pos) = engine.get_positions().iter().find(|p| p.market_slug == signal.market_slug) {                                                    let position_response = PositionResponse {                                                        id: pos.id.clone(),                                                        asset: format!("{:?}", pos.asset),                                                        timeframe: format!("{:?}", pos.timeframe),                                                        direction: format!("{:?}", pos.direction),                                                        entry_price: pos.entry_price,                                                        current_price: pos.current_price,                                                        size_usdc: pos.size_usdc,                                                        pnl: pos.unrealized_pnl,                                                        pnl_pct: 0.0,                                                        opened_at: pos.opened_at,                                                        market_slug: pos.market_slug.clone(),                                                        confidence: pos.confidence,                                                        peak_price: pos.peak_price,                                                        trough_price: pos.trough_price,                                                        market_close_ts: pos.market_close_ts,                                                        time_remaining_secs: ((pos.market_close_ts - chrono::Utc::now().timestamp_millis()) / 1000).max(0),                                                    };                                                    main_loop_broadcaster.broadcast_position_opened(position_response);                                                }                                                // Also broadcast updated stats                                                let stats = engine.get_stats();                                                let balance = engine.get_balance();                                                let locked = engine.get_locked_balance();                                                let equity = engine.get_total_equity();                                                let stats_response = crate::dashboard::PaperStatsResponse {                                                    total_trades: stats.total_trades,                                                    wins: stats.wins,                                                    losses: stats.losses,                                                    win_rate: if stats.total_trades > 0 {                                                        (stats.wins as f64 / stats.total_trades as f64) * 100.0                                                    } else { 0.0 },                                                    total_pnl: stats.total_pnl,                                                    total_fees: stats.total_fees,                                                    largest_win: stats.largest_win,                                                    largest_loss: stats.largest_loss,                                                    avg_win: if stats.wins > 0 { stats.sum_win_pnl / stats.wins as f64 } else { 0.0 },                                                    avg_loss: if stats.losses > 0 { stats.sum_loss_pnl / stats.losses as f64 } else { 0.0 },                                                    max_drawdown: stats.max_drawdown,                                                    current_drawdown: {                                                        let peak = stats.peak_balance;                                                        if peak > 0.0 { ((peak - equity) / peak * 100.0).max(0.0) } else { 0.0 }                                                    },                                                    peak_balance: stats.peak_balance,                                                    profit_factor: if stats.gross_loss > 0.0 {                                                        stats.gross_profit / stats.gross_loss                                                    } else if stats.gross_profit > 0.0 { f64::INFINITY } else { 0.0 },                                                    current_streak: stats.current_streak,                                                    best_streak: stats.best_streak,                                                    worst_streak: stats.worst_streak,                                                    exits_trailing_stop: stats.exits_trailing_stop,                                                    exits_take_profit: stats.exits_take_profit,                                                    exits_market_expiry: stats.exits_market_expiry,                                                    exits_time_expiry: stats.exits_time_expiry,                                                };                                                main_loop_broadcaster.broadcast_stats(stats_response);                                            }                                        }                                        Ok(false) => {                                            info!(signal_id = %signal_id, "üìã [PAPER] Order rejected (balance/position)");                                            #[cfg(feature = "dashboard")]                                            paper_dashboard_memory                                                .record_execution_rejection("paper_engine_rejected")                                                .await;                                        }                                        Err(e) => {                                            error!(error = %e, "üìã [PAPER] Execute failed");                                            #[cfg(feature = "dashboard")]                                            paper_dashboard_memory                                                .record_execution_rejection("paper_execute_error")                                                .await;                                        }                                    }                                } else {                                    info!(                                        signal_id = %signal_id,                                        "‚è∏Ô∏è Signal rejected by risk manager"                                    );                                    #[cfg(feature = "dashboard")]                                    paper_dashboard_memory                                        .record_execution_rejection("risk_manager_rejected")                                        .await;                                }                            }                            Err(e) => {                                error!(error = %e, "Risk evaluation failed");                                #[cfg(feature = "dashboard")]                                paper_dashboard_memory                                    .record_execution_rejection("risk_evaluation_error")                                    .await;                            }                        }                    }                    continue;                }                // ‚îÄ‚îÄ Live / Dry-Run path ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ                let window_ms = signal.timeframe.duration_secs() as i64 * 1000;                let window_start = if signal.expires_at > 0 {                    signal.expires_at - window_ms                } else {                    (signal.ts / window_ms) * window_ms                };                let live_bias_key = (signal.asset, signal.timeframe, window_start);                {                    let mut bias_map = live_window_bias.lock().await;                    let cutoff = chrono::Utc::now().timestamp_millis()                        - (Timeframe::Hour1.duration_secs() as i64 * 1000 * 2);                    bias_map.retain(|(_, _, ws), _| *ws >= cutoff);                    if let Some(existing) = bias_map.get(&live_bias_key) {                        if *existing != signal.direction {                            warn!(                                signal_id = %signal_id,                                asset = ?signal.asset,                                timeframe = ?signal.timeframe,                                window_start = window_start,                                existing = ?existing,                                incoming = ?signal.direction,                                "Skipping live signal: opposite bias already active for window"                            );                            continue;                        }                    }                }                // Apply risk checks                match risk_manager.evaluate(&signal) {                    Ok(approved) => {                        if approved {                            info!(                                signal_id = %signal_id,                                asset = %signal.asset,                                direction = ?signal.direction,                                confidence = %signal.confidence,                                "üìà Signal approved by risk manager"                            );                            let market_slug = &signal.market_slug;                            let token_id = signal.token_id.clone();                            if token_id.trim().is_empty() {                                warn!(                                    signal_id = %signal_id,                                    market_slug = %market_slug,                                    "Could not resolve token_id from strategy signal, skipping order"                                );                                continue;                            }                            info!(                                signal_id = %signal_id,                                market_slug = %market_slug,                                token_id = %token_id,                                "üéØ Token ID resolved"                            );                            let quote = match clob_client.quote_token(&token_id).await {                                Ok(q) => q,                                Err(e) => {                                    warn!(                                        signal_id = %signal_id,                                        token_id = %token_id,                                        error = %e,                                        "Could not quote token, skipping order"                                    );                                    continue;                                }                            };                            let p_market = quote.mid.clamp(0.01, 0.99);                            let max_spread = match signal.timeframe {                                Timeframe::Min15 => 0.03,                                Timeframe::Hour1 => 0.05,                            };                            if quote.spread > max_spread {                                info!(                                    signal_id = %signal_id,                                    spread = quote.spread,                                    max_spread = max_spread,                                    "Skipping order due to spread policy"                                );                                continue;                            }                            let min_depth_top5 = match signal.timeframe {                                Timeframe::Min15 => 50.0,                                Timeframe::Hour1 => 25.0,                            };                            if quote.depth_top5 > 0.0 && quote.depth_top5 < min_depth_top5 {                                info!(                                    signal_id = %signal_id,                                    depth_top5 = quote.depth_top5,                                    min_depth_top5 = min_depth_top5,                                    "Skipping order due to low depth policy"                                );                                continue;                            }                            let fee_rate = crate::polymarket::fee_rate_from_price(p_market);                            let ev = crate::polymarket::estimate_expected_value(                                p_market,                                signal.confidence.clamp(0.01, 0.99),                                p_market,                                fee_rate,                                quote.spread.max(0.0),                                0.005,                            );                            if ev.edge_net <= 0.0 {                                info!(                                    signal_id = %signal_id,                                    edge_net = ev.edge_net,                                    "Skipping order due to non-positive edge after costs"                                );                                continue;                            }                            let now_ms = chrono::Utc::now().timestamp_millis();                            let seconds_to_expiry = if signal.expires_at > 0 {                                ((signal.expires_at - now_ms) / 1000).max(0)                            } else {                                i64::MAX                            };                            let exec_plan = match crate::polymarket::plan_buy_execution(                                quote.bid,                                quote.ask,                                0.001,                                config.execution.maker_first,                                config.execution.post_only,                                seconds_to_expiry,                                config.execution.fallback_taker_seconds_to_expiry,                                ev.edge_net,                            ) {                                Some(plan) => plan,                                None => {                                    warn!(                                        signal_id = %signal_id,                                        bid = quote.bid,                                        ask = quote.ask,                                        "Invalid quote for execution plan"                                    );                                    continue;                                }                            };                            // Always BUY the selected outcome token.                            let shares_size = if exec_plan.entry_price > 0.0 {                                (signal.suggested_size_usdc / exec_plan.entry_price).max(0.0)                            } else {                                0.0                            };                            if shares_size <= 0.0 {                                warn!(                                    signal_id = %signal_id,                                    notional_usdc = signal.suggested_size_usdc,                                    entry_price = exec_plan.entry_price,                                    "Skipping order due to non-positive share size"                                );                                continue;                            }                            let mut order = Order::new(                                token_id,                                clob::Side::Buy,                                exec_plan.entry_price,                                shares_size,                            );                            if exec_plan.post_only {                                order.expiration = signal.expires_at.max(0) as u64;                            }                            if let Err(e) = order_tx.send(order).await {                                error!(error = %e, "Failed to send order");                            } else {                                live_window_bias                                    .lock()                                    .await                                    .insert(live_bias_key, signal.direction);                                // ‚îÄ‚îÄ Store indicators used for this position (for live calibration) ‚îÄ‚îÄ                                // When the position closes, the monitor will look these up                                // to train the calibrator                                if !signal.indicators_used.is_empty() {                                    live_indicators_for_main.lock().await.insert(                                        (signal.asset, signal.timeframe),                                        (signal.indicators_used.clone(), signal.confidence.clamp(0.01, 0.99)),                                    );                                    info!(                                        signal_id = %signal_id,                                        asset = ?signal.asset,                                        indicators_count = signal.indicators_used.len(),                                        "üìä [LIVE] Stored indicators for calibration on close"                                    );                                }                            }                        } else {                            info!(                                signal_id = %signal_id,                                "‚è∏Ô∏è Signal rejected by risk manager"                            );                                    #[cfg(feature = "dashboard")]                                    paper_dashboard_memory                                        .record_execution_rejection("risk_manager_rejected")                                        .await;                        }                    }                    Err(e) => {                        error!(error = %e, "Risk evaluation failed");                                #[cfg(feature = "dashboard")]                                paper_dashboard_memory                                    .record_execution_rejection("risk_evaluation_error")                                    .await;                    }                }            }            // Handle Ctrl+C            _ = tokio::signal::ctrl_c() => {                info!("üõë Shutdown signal received");                break;            }        }    }    // Graceful shutdown    info!("Shutting down...");    oracle_handle.abort();    feature_handle.abort();    strategy_handle.abort();    execution_handle.abort();    position_handle.abort();    balance_handle.abort();    if let Some(handle) = paper_monitor_handle {        handle.abort();    }    // Print final paper trading stats    if let Some(ref engine) = paper_engine {        info!("üìã ‚ïê‚ïê‚ïê FINAL PAPER TRADING REPORT ‚ïê‚ïê‚ïê");        engine.print_dashboard();        info!("{}", engine.summary_string());    }    // Flush pending data    // csv_persistence automatically flushes on each write    info!("üëã PolyBot stopped");    Ok(())}#[cfg(feature = "dashboard")]fn paper_trade_record_to_dashboard_trade(    record: &crate::paper_trading::PaperTradeRecord,) -> TradeResponse {    TradeResponse {        timestamp: record.timestamp,        trade_id: record.trade_id.clone(),        asset: record.asset.clone(),        timeframe: record.timeframe.clone(),        direction: record.direction.clone(),        confidence: record.confidence,        entry_price: record.entry_price,        exit_price: record.exit_price,        size_usdc: record.size_usdc,        pnl: record.pnl,        pnl_pct: record.pnl_pct,        result: record.result.clone(),        exit_reason: record.exit_reason.clone(),        hold_duration_secs: record.hold_duration_ms / 1000,        balance_after: record.balance_after,        rsi_at_entry: None,        macd_hist_at_entry: None,        bb_position_at_entry: None,        adx_at_entry: None,        volatility_at_entry: None,    }}#[derive(Debug, Default)]struct RuntimeArgs {    reset_mode: Option<String>,    no_backup: bool,}fn parse_runtime_args() -> Result<RuntimeArgs> {    let mut args = RuntimeArgs::default();    let mut iter = std::env::args().skip(1);    while let Some(arg) = iter.next() {        if arg == "--no-backup" {            args.no_backup = true;            continue;        }        if arg == "--reset" {            let mode = iter.next().ok_or_else(|| {                anyhow::anyhow!("--reset requires a mode (supported: hard-all-history)")            })?;            args.reset_mode = Some(mode);            continue;        }        if let Some(mode) = arg.strip_prefix("--reset=") {            if mode.trim().is_empty() {                anyhow::bail!("--reset requires a mode (supported: hard-all-history)");            }            args.reset_mode = Some(mode.to_string());        }    }    Ok(args)}fn maybe_run_startup_reset(config: &AppConfig, runtime_args: &RuntimeArgs) -> Result<bool> {    let requested_mode = runtime_args        .reset_mode        .as_ref()        .map(|s| s.as_str())        .or_else(|| {            if config.reset.enabled_on_start {                Some(config.reset.mode.as_str())            } else {                None            }        });    let Some(mode) = requested_mode else {        return Ok(false);    };    let normalized_mode = mode.to_ascii_lowercase().replace('-', "_");    if normalized_mode != "hard_all_history" {        anyhow::bail!(            "Unsupported reset mode '{}'. Supported: hard_all_history / hard-all-history",            mode        );    }    let options = HardResetOptions {        no_backup: runtime_args.no_backup || config.reset.no_backup,        delete_prices: config.reset.delete_prices,        delete_learning_state: config.reset.delete_learning_state,        delete_paper_state: config.reset.delete_paper_state,    };    info!(        mode = %normalized_mode,        no_backup = options.no_backup,        delete_prices = options.delete_prices,        delete_learning_state = options.delete_learning_state,        delete_paper_state = options.delete_paper_state,        data_dir = %config.persistence.data_dir,        "Executing startup hard reset"    );    CsvPersistence::hard_reset_with_options(&config.persistence.data_dir, options)?;    Ok(true)}fn default_anchor_price(asset: Asset) -> f64 {    match asset {        Asset::BTC => 100_000.0,        Asset::ETH => 3_000.0,        Asset::SOL => 200.0,        Asset::XRP => 1.0,    }}fn normalize_history_timestamp_ms(ts: i64) -> i64 {    if ts.abs() < 100_000_000_000 {        ts.saturating_mul(1000)    } else {        ts    }}fn load_local_price_points(data_dir: &str, asset: Asset, lookback_hours: i64) -> Vec<(i64, f64)> {    use chrono::{Duration, Utc};    use std::path::PathBuf;    let mut rows: Vec<(i64, f64)> = Vec::new();    let now = Utc::now();    let start_ts = now.timestamp_millis() - lookback_hours.max(1) * 3_600_000;    let days = ((lookback_hours.max(1) + 23) / 24) + 2;    let prices_dir = PathBuf::from(data_dir).join("prices");    let asset_label = asset.to_string();    for day_offset in 0..=days {        let date = now - Duration::days(day_offset);        let filename = format!("prices_{}.csv", date.format("%Y-%m-%d"));        let path = prices_dir.join(filename);        if !path.exists() {            continue;        }        let Ok(content) = std::fs::read_to_string(&path) else {            continue;        };        for line in content.lines() {            let trimmed = line.trim();            if trimmed.is_empty() {                continue;            }            let cols: Vec<&str> = trimmed.split(',').map(str::trim).collect();            if cols.len() < 3 {                continue;            }            let Ok(raw_ts) = cols[0].parse::<i64>() else {                continue;            };            let ts = normalize_history_timestamp_ms(raw_ts);            if ts < start_ts {                continue;            }            if !cols[1].eq_ignore_ascii_case(&asset_label) {                continue;            }            let Ok(price) = cols[2].parse::<f64>() else {                continue;            };            if !price.is_finite() || price <= 0.0 {                continue;            }            rows.push((ts, price));        }    }    rows.sort_by_key(|(ts, _)| *ts);    rows}fn build_candles_from_points(    asset: Asset,    timeframe: Timeframe,    points: &[(i64, f64)],) -> Vec<crate::types::Candle> {    use std::collections::BTreeMap;    #[derive(Clone, Copy)]    struct Bucket {        open: f64,        high: f64,        low: f64,        close: f64,        trades: u64,    }    if points.is_empty() {        return Vec::new();    }    let tf_ms = timeframe.duration_secs() as i64 * 1000;    let mut buckets: BTreeMap<i64, Bucket> = BTreeMap::new();    for (raw_ts, price) in points.iter().copied() {        if !price.is_finite() || price <= 0.0 {            continue;        }        let ts = normalize_history_timestamp_ms(raw_ts);        let bucket_open = (ts / tf_ms) * tf_ms;        buckets            .entry(bucket_open)            .and_modify(|b| {                b.high = b.high.max(price);                b.low = b.low.min(price);                b.close = price;                b.trades = b.trades.saturating_add(1);            })            .or_insert(Bucket {                open: price,                high: price,                low: price,                close: price,                trades: 1,            });    }    let mut candles = Vec::with_capacity(buckets.len());    for (open_time, bucket) in buckets {        candles.push(crate::types::Candle {            open_time,            close_time: open_time + tf_ms - 1,            asset,            timeframe,            open: bucket.open,            high: bucket.high,            low: bucket.low,            close: bucket.close,            volume: 0.0,            trades: bucket.trades,        });    }    candles}fn dedup_candles_by_open_time(candles: Vec<crate::types::Candle>) -> Vec<crate::types::Candle> {    use std::collections::BTreeMap;    let mut by_open: BTreeMap<i64, crate::types::Candle> = BTreeMap::new();    for candle in candles {        by_open.insert(candle.open_time, candle);    }    by_open.into_values().collect()}async fn bootstrap_polymarket_history_candles(    client: &ClobClient,    market_slug: &str,    asset: Asset,    timeframe: Timeframe,    anchor_price: f64,    interval: crate::clob::PriceHistoryInterval,) -> Result<Vec<crate::types::Candle>> {    let mut market = client.find_market_by_slug(market_slug).await;    if market.is_none() {        let keyword = match asset {            Asset::BTC => "bitcoin",            Asset::ETH => "ethereum",            Asset::SOL => "solana",            Asset::XRP => "xrp",        };        let mut fallback = client.find_markets(keyword).await;        fallback.retain(|m| m.active);        fallback.sort_by(|a, b| {            let text_a = format!(                "{} {}",                a.slug.clone().unwrap_or_default(),                a.question.to_ascii_lowercase()            );            let text_b = format!(                "{} {}",                b.slug.clone().unwrap_or_default(),                b.question.to_ascii_lowercase()            );            let tf_match_a = parse_timeframe_from_market_text(&text_a)                .map(|tf| tf == timeframe)                .unwrap_or(false);            let tf_match_b = parse_timeframe_from_market_text(&text_b)                .map(|tf| tf == timeframe)                .unwrap_or(false);            let expiry_a = a                .end_date_iso                .as_deref()                .and_then(crate::clob::ClobClient::parse_expiry_to_timestamp)                .unwrap_or(i64::MAX);            let expiry_b = b                .end_date_iso                .as_deref()                .and_then(crate::clob::ClobClient::parse_expiry_to_timestamp)                .unwrap_or(i64::MAX);            tf_match_b                .cmp(&tf_match_a)                .then_with(|| expiry_a.cmp(&expiry_b))        });        market = fallback.into_iter().next();    }    let market = market.ok_or_else(|| anyhow::anyhow!("Market slug '{}' not found", market_slug))?;    let token_id = client        .find_token_id_for_direction(market_slug, Direction::Up)        .await        .or_else(|| {            market                .tokens                .iter()                .find(|t| {                    let out = t.outcome.to_ascii_lowercase();                    out.contains("yes") || out.contains("up")                })                .map(|t| t.token_id.clone())        })        .or_else(|| market.tokens.first().map(|t| t.token_id.clone()))        .ok_or_else(|| anyhow::anyhow!("No token available for market '{}'", market_slug))?;    let now_ms = chrono::Utc::now().timestamp_millis();    let lookback_ms = match timeframe {        Timeframe::Min15 => 7 * 24 * 3_600_000i64,        Timeframe::Hour1 => 30 * 24 * 3_600_000i64,    };    let points = match client        .get_token_price_history(            &token_id,            interval,            Some((now_ms - lookback_ms) / 1000),            Some(now_ms / 1000),            None,        )        .await    {        Ok(points) => points,        Err(primary_err) => {            // Some markets reject explicit time bounds on specific intervals.            match client                .get_token_price_history(&token_id, interval, None, None, None)                .await            {                Ok(points) => points,                Err(fallback_err) => {                    let alt_max = crate::clob::PriceHistoryInterval::Max;                    match client                        .get_token_price_history(&token_id, alt_max, None, None, None)                        .await                    {                        Ok(points) => points,                        Err(max_err) => {                            let alt_day = crate::clob::PriceHistoryInterval::OneDay;                            client                                .get_token_price_history(&token_id, alt_day, None, None, None)                                .await                                .map_err(|day_err| {                                    anyhow::anyhow!(                                        "price history failed primary='{}' fallback='{}' max='{}' day='{}'",                                        primary_err,                                        fallback_err,                                        max_err,                                        day_err                                    )                                })?                        }                    }                }            }        }    };    if points.is_empty() {        return Ok(Vec::new());    }    let mut prob_points: Vec<(i64, f64)> = points        .into_iter()        .filter_map(|point| {            if !point.p.is_finite() || point.p <= 0.0 {                return None;            }            Some((normalize_history_timestamp_ms(point.t), point.p.clamp(0.0001, 0.9999)))        })        .collect();    prob_points.sort_by_key(|(ts, _)| *ts);    prob_points.dedup_by_key(|(ts, _)| *ts);    if prob_points.len() < 2 {        return Ok(Vec::new());    }    // Convert token-probability history into a spot-like synthetic series using returns.    let mut synthetic: Vec<(i64, f64)> = Vec::with_capacity(prob_points.len());    let (first_ts, first_p) = prob_points[0];    let mut prev_prob = first_p.max(0.0001);    let mut synthetic_price = anchor_price.max(1.0);    synthetic.push((first_ts, synthetic_price));    for (ts, prob) in prob_points.into_iter().skip(1) {        let raw_ret = (prob / prev_prob) - 1.0;        let scaled_ret = (raw_ret * 0.35).clamp(-0.03, 0.03);        synthetic_price = (synthetic_price * (1.0 + scaled_ret)).max(0.01);        synthetic.push((ts, synthetic_price));        prev_prob = prob.max(0.0001);    }    Ok(build_candles_from_points(asset, timeframe, &synthetic))}fn parse_timeframe_from_market_text(raw: &str) -> Option<Timeframe> {    let text = raw.to_ascii_lowercase();    if text.contains("15m")        || text.contains("min15")        || text.contains("m15")        || text.contains("15 min")        || text.contains("15-minute")        || text.contains("15 minute")    {        return Some(Timeframe::Min15);    }    if text.contains("1h")        || text.contains("hour1")        || text.contains("h1")        || text.contains("1 hour")        || text.contains("60m")        || text.contains("60 min")        || text.contains("60-minute")    {        return Some(Timeframe::Hour1);    }    None}fn init_logging() -> Result<()> {    // Default to INFO level. Set RUST_LOG=polybot=debug to see verbose logs    let filter = EnvFilter::try_from_default_env().unwrap_or_else(|_| EnvFilter::new("info"));    tracing_subscriber::registry()        .with(filter)        .with(fmt::layer().with_target(false).with_thread_ids(false))        .with(            fmt::layer()                .json()                .with_target(true)                .with_writer(std::io::stderr),        )        .try_init()?;    Ok(())}
